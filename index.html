<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Roblox-Style Movement + Mobile Multi-Touch Joystick</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

<style>
html, body {margin:0; height:100%; overflow:hidden; background:#0e0f12; color:white; -webkit-user-select:none; user-select:none; touch-action:none;}
#scene {width:100%; height:100%; display:block; touch-action:none;}
#loading {position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); color:#77c0ff; font-size:20px;}
#hud {position:absolute; top:20px; left:20px; color:#77c0ff; font-size:14px; background:rgba(0,0,0,0.4); padding:6px 10px; border-radius:6px; z-index:30;}
#shiftLockIndicator {position:absolute; top:20px; right:120px; z-index:31; background:rgba(13,16,24,0.85); border:1px solid rgba(119,192,255,0.3); color:#9fd0ff; padding:7px 14px; border-radius:999px; font-size:12px; letter-spacing:0.3px; box-shadow:0 6px 20px rgba(0,0,0,0.4); transition:background 0.3s ease, border-color 0.3s ease, color 0.3s ease, transform 0.2s ease;}
#shiftLockIndicator.active {background:rgba(119,192,255,0.2); border-color:rgba(119,192,255,0.8); color:#fff; transform:translateY(-1px);}

/* Left joystick */
#leftJoy {
  position:absolute; left:40px; bottom:40px;
  width:120px; height:120px;
  border-radius:50%; background: rgba(255,255,255,0.12); border:2px solid rgba(255,255,255,0.25);
  touch-action:none; z-index:20;
}
#leftJoy .stick {
  position:absolute; width:50px; height:50px; border-radius:50%; background: rgba(255,255,255,0.35);
  left:35px; top:35px;
  touch-action:none;
}
#touch-hint {
  position:absolute; left:50%; bottom:18px; transform:translateX(-50%);
  color:rgba(119,192,255,0.9); font-size:12px;
  background: rgba(0,0,0,0.35); padding:6px 10px; border-radius:8px; z-index:20;
}

/* Sprint Button (Mobile) */
#sprintBtn {
  position: absolute;
  right: 40px;
  bottom: 40px;
  width: 90px;
  height: 90px;
  border-radius: 50%;
  background: rgba(255,255,255,0.12);
  border: 2px solid rgba(255,255,255,0.25);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  color: #77c0ff;
  z-index: 25;
  user-select: none;
  touch-action: none;
  transition: background 0.15s, transform 0.1s;
}
#sprintBtn.active {
  background: rgba(119,192,255,0.28);
  transform: scale(1.08);
}

/* Settings menu */
#settingsBtn {
  position:absolute; top:20px; right:20px; z-index:31;
  background:rgba(119,192,255,0.2); border:1px solid rgba(119,192,255,0.5);
  color:#77c0ff; padding:8px 12px; border-radius:6px; cursor:pointer; font-size:12px;
  transition:transform 0.2s ease, background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
  box-shadow:0 8px 18px rgba(119,192,255,0.25);
}
#settingsBtn:hover { background:rgba(119,192,255,0.4); border-color:rgba(119,192,255,0.8); transform:translateY(-1px) scale(1.02); box-shadow:0 12px 28px rgba(119,192,255,0.35); }

#settingsOverlay {
  position:fixed; top:0; left:0; right:0; bottom:0;
  background:rgba(0,0,0,0.7); z-index:100; backdrop-filter:blur(6px);
  display:flex; align-items:center; justify-content:center;
  opacity:0; visibility:hidden; pointer-events:none;
  transition:opacity 0.35s ease, visibility 0s linear 0.35s;
}
#settingsOverlay.visible {
  opacity:1; visibility:visible; pointer-events:auto;
  transition:opacity 0.35s ease;
}
#settingsMenu {
  position:relative;
  background:rgba(20,22,28,0.95); border:2px solid rgba(119,192,255,0.3);
  padding:30px; border-radius:12px; max-width:400px; width:90%;
  box-shadow:0 8px 32px rgba(0,0,0,0.5);
  transform:translateY(20px) scale(0.96);
  opacity:0;
  transition:transform 0.4s cubic-bezier(0.16,1,0.3,1), opacity 0.3s ease;
}
#settingsOverlay.visible #settingsMenu { transform:translateY(0) scale(1); opacity:1; }
#settingsMenu h2 {
  margin:0 0 20px 0; color:#77c0ff; font-size:18px;
}
.setting-row {
  margin-bottom:16px; display:flex; justify-content:space-between; align-items:center;
}
.setting-row label { color:#aaa; font-size:12px; }
.setting-row input[type="range"] {
  width:60%; cursor:pointer;
}
.setting-row input[type="checkbox"] {
  cursor:pointer; width:18px; height:18px;
}
.setting-row select {
  background:rgba(255,255,255,0.08); border:1px solid rgba(119,192,255,0.3);
  color:#77c0ff; padding:6px 8px; border-radius:4px; cursor:pointer; font-size:12px;
}
#settingsMenu button {
  background:rgba(119,192,255,0.2); border:1px solid rgba(119,192,255,0.5);
  color:#77c0ff; padding:8px 12px; border-radius:6px; cursor:pointer; margin-right:8px;
  transition:all 0.2s; font-size:12px;
}
#settingsMenu button:hover { background:rgba(119,192,255,0.4); }
#settingsMenu .button-group {
  margin-top:20px; display:flex; justify-content:flex-end;
}
</style>

<script type="importmap">
{
  "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" }
}
</script>
</head>
<body>
<canvas id="scene"></canvas>
<div id="loading">Loading player…</div>
<div id="hud">Right-click + drag to rotate camera | WASD to move</div>
<button id="settingsBtn">⚙ Settings</button>
<div id="shiftLockIndicator">Ctrl Lock: Off</div>

<!-- Left joystick -->
<div id="leftJoy">
  <div class="stick" id="leftStick"></div>
</div>

<!-- Sprint Button (Mobile) -->
<div id="sprintBtn">Sprint</div>

<div id="touch-hint">Left: move • Right: look</div>

<!-- Settings menu -->
<div id="settingsOverlay">
  <div id="settingsMenu">
    <h2>Settings</h2>
    <div class="setting-row">
      <label>Mouse Sensitivity</label>
      <input type="range" id="mouseSensitivity" min="0.5" max="3" step="0.1" value="1">
    </div>
    <div class="setting-row">
      <label>Gamepad Deadzone</label>
      <input type="range" id="gamepadDeadzone" min="0" max="0.5" step="0.05" value="0.1">
    </div>
    <div class="setting-row">
      <label>Gamepad Sensitivity</label>
      <input type="range" id="gamepadSensitivity" min="0.5" max="3" step="0.1" value="1">
    </div>
    <div class="setting-row">
      <label>Graphics Quality</label>
      <select id="graphicsQuality">
        <option value="low">Low</option>
        <option value="medium" selected>Medium</option>
        <option value="high">High</option>
      </select>
    </div>
    <div class="setting-row">
      <label>Show FPS</label>
      <input type="checkbox" id="showFPS">
    </div>
    <div class="button-group">
      <button id="settingsClose">Close</button>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from "three";
import { GLTFLoader } from "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";

const hud=document.getElementById('hud');
const shiftLockIndicator=document.getElementById('shiftLockIndicator');
const settingsOverlay=document.getElementById('settingsOverlay');
const baseHudMessage='Right-click + drag to rotate camera | WASD to move | Hold Shift to sprint | Press Ctrl for Ctrl Lock';
const hudState={gamepad:false};
let shiftLockEnabled=false;
let fpsCounter=0, fpsDisplay=0;
let isSprinting=false;

// ---------- Settings ----------
const settings = {
  mouseSensitivity: 1,
  gamepadDeadzone: 0.1,
  gamepadSensitivity: 1,
  graphicsQuality: 'medium',
  showFPS: false
};

function updateHud(){
  if(settings.showFPS){
    hud.textContent=`FPS: ${fpsDisplay} | Right-click + drag to rotate camera | WASD to move | Gamepad: ${hudState.gamepad?'✓':'✗'} | Ctrl Lock: ${shiftLockEnabled?'On':'Off'} | Sprint: ${isSprinting?'On':'Off'}`;
  } else {
    hud.textContent=`${baseHudMessage} | Ctrl Lock: ${shiftLockEnabled?'On':'Off'}`;
  }
}

function updateSettingsUI(){
  document.getElementById('mouseSensitivity').value = settings.mouseSensitivity;
  document.getElementById('gamepadDeadzone').value = settings.gamepadDeadzone;
  document.getElementById('gamepadSensitivity').value = settings.gamepadSensitivity;
  document.getElementById('graphicsQuality').value = settings.graphicsQuality;
  document.getElementById('showFPS').checked = settings.showFPS;
}

document.getElementById('mouseSensitivity').addEventListener('change', e=>{ settings.mouseSensitivity=parseFloat(e.target.value); });
document.getElementById('gamepadDeadzone').addEventListener('change', e=>{ settings.gamepadDeadzone=parseFloat(e.target.value); });
document.getElementById('gamepadSensitivity').addEventListener('change', e=>{ settings.gamepadSensitivity=parseFloat(e.target.value); });
document.getElementById('graphicsQuality').addEventListener('change', e=>{ settings.graphicsQuality=e.target.value; });
document.getElementById('showFPS').addEventListener('change', e=>{ settings.showFPS=e.target.checked; updateHud(); });

document.getElementById('settingsBtn').addEventListener('click', ()=>settingsOverlay.classList.add('visible'));
document.getElementById('settingsClose').addEventListener('click', ()=>settingsOverlay.classList.remove('visible'));

settingsOverlay.addEventListener('click', e=>{
  if(e.target===settingsOverlay) settingsOverlay.classList.remove('visible');
});

updateSettingsUI();
updateHud();

// ---------- Hide joystick on PC ----------
if (!('ontouchstart' in window)) {
  document.getElementById('leftJoy').style.display = 'none';
  document.getElementById('touch-hint').style.display = 'none';
  document.getElementById('sprintBtn').style.display = 'none';
}

// ---------- Three.js ----------
const canvas = document.getElementById("scene");
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
renderer.setSize(window.innerWidth, window.innerHeight);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a1d22);
const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight,0.1,500);

scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1));
const light = new THREE.DirectionalLight(0xffffff,1.4);
light.position.set(5,10,7);
scene.add(light);

const ground = new THREE.Mesh(new THREE.PlaneGeometry(100,100), new THREE.MeshStandardMaterial({color:0x202226}));
ground.rotation.x=-Math.PI/2;
scene.add(ground);

// Terrain objects
const geometry = new THREE.BoxGeometry(8,3,8);
const material = new THREE.MeshStandardMaterial({color:0x3a3d42});

const rock1 = new THREE.Mesh(geometry, material); rock1.position.set(15, 1.5, 20); scene.add(rock1);
const rock2 = new THREE.Mesh(geometry, material); rock2.position.set(-20, 1.5, 15); scene.add(rock2);
const rock3 = new THREE.Mesh(geometry, material); rock3.position.set(0, 1.5, -25); scene.add(rock3);

const pillarGeom = new THREE.CylinderGeometry(2,2,5,8);
const pillarMat = new THREE.MeshStandardMaterial({color:0x4a5563});
const pillar1 = new THREE.Mesh(pillarGeom, pillarMat); pillar1.position.set(-15, 2.5, -15); scene.add(pillar1);
const pillar2 = new THREE.Mesh(pillarGeom, pillarMat); pillar2.position.set(25, 2.5, 0); scene.add(pillar2);

const platformGeom = new THREE.BoxGeometry(12,0.5,12);
const platformMat = new THREE.MeshStandardMaterial({color:0x5a6370});
const platform = new THREE.Mesh(platformGeom, platformMat); platform.position.set(-35, 2, 30); scene.add(platform);

const wallGeom = new THREE.BoxGeometry(20,4,1);
const wallMat = new THREE.MeshStandardMaterial({color:0x454a52});
const wall1 = new THREE.Mesh(wallGeom, wallMat); wall1.position.set(30, 2, -30); scene.add(wall1);
const wall2 = new THREE.Mesh(wallGeom, wallMat); wall2.position.set(-30, 2, 30); wall2.rotation.y=Math.PI/2; scene.add(wall2);

// ---------- Player ----------
let model, mixer, idleAction, walkAction, runAction;
const loader = new GLTFLoader();
const playerState = { pos:new THREE.Vector3(0,0,0), rot:0, moving:false };
let currentAnim = 'idle';

function loadPlayer(){
  loader.load("./model/idle.glb", idleGLB=>{
    model=idleGLB.scene;
    model.scale.set(0.35,0.35,0.35);
    model.rotation.y=Math.PI;
    scene.add(model);
    mixer=new THREE.AnimationMixer(model);
    idleAction=mixer.clipAction(idleGLB.animations[0]);
    idleAction.play();

    loader.load("./model/walk.glb", walkGLB=>{
      walkAction=mixer.clipAction(walkGLB.animations[0]);
      walkAction.timeScale=2;

      loader.load("./model/run.glb", runGLB=>{
        runAction=mixer.clipAction(runGLB.animations[0]);
        runAction.timeScale=3.3;
        document.getElementById("loading").style.display="none";
      }, undefined, err=>{
        console.log("Run animation missing, using walk.");
        runAction = walkAction;
        document.getElementById("loading").style.display="none";
      });

    }, undefined, err=>{
      walkAction = idleAction;
      runAction = idleAction;
      document.getElementById("loading").style.display="none";
    });

  }, undefined, err=>{
    console.error("Model load error:", err);
    const fallbackGeom=new THREE.CapsuleGeometry(0.5,1,4,8);
    const fallbackMat=new THREE.MeshStandardMaterial({color:0x77c0ff});
    model=new THREE.Mesh(fallbackGeom,fallbackMat);
    model.position.copy(playerState.pos);
    scene.add(model);
    setTimeout(()=>document.getElementById("loading").style.display="none",1000);
  });
}
loadPlayer();

// ---------- Camera ----------
let camYaw=0, camPitch=-0.35, camDist=6, camHeight=3;

// ---------- Input ----------
const keys = {KeyW:false, KeyA:false, KeyS:false, KeyD:false, ShiftLeft:false, ShiftRight:false};
window.addEventListener("keydown",e=>{ if(keys[e.code]!==undefined) keys[e.code]=true; if(e.code.includes("Control")&&!e.repeat) toggleShiftLock(); });
window.addEventListener("keyup",e=>{ if(keys[e.code]!==undefined) keys[e.code]=false; });

// Mouse look
let dragging=false;
document.addEventListener("contextmenu", e=>e.preventDefault());
document.addEventListener("mousedown", e=>{ if(e.button===2) dragging=true; });
document.addEventListener("mouseup", ()=>dragging=false);
document.addEventListener("mousemove", e=>{
  if(!dragging && !shiftLockEnabled) return;
  camYaw -= e.movementX*0.003*settings.mouseSensitivity;
  camPitch += e.movementY*0.003*settings.mouseSensitivity;
  camPitch=Math.max(-1.2, Math.min(0.4, camPitch));
});

// Pointer lock
function setShiftLockState(state){
  shiftLockEnabled=state;
  shiftLockIndicator.textContent=state?'Ctrl Lock: On':'Ctrl Lock: Off';
  shiftLockIndicator.classList.toggle('active', state);
  updateHud();
}
function toggleShiftLock(){
  if(!canvas.requestPointerLock) return;
  if(document.pointerLockElement===canvas) document.exitPointerLock();
  else canvas.requestPointerLock();
}
document.addEventListener("pointerlockchange", ()=>{
  setShiftLockState(document.pointerLockElement===canvas);
  if(!document.pointerLockElement) dragging=false;
});
document.addEventListener("pointerlockerror", ()=>setShiftLockState(false));

// ---------- Gamepad ----------
const gamepad={active:null};
function updateGamepadInput(){
  const pads=navigator.getGamepads();
  if(!pads[0]){gamepad.active=null; return;}
  gamepad.active=pads[0];
}
window.addEventListener("gamepadconnected", e=>console.log("Gamepad:",e.gamepad.id));
window.addEventListener("gamepaddisconnected", e=>{ if(gamepad.active?.index===e.gamepad.index) gamepad.active=null; });

// ---------- Left Joystick ----------
const leftJoyEl=document.getElementById("leftJoy");
const leftStickEl=document.getElementById("leftStick");
const leftJoy={active:false, id:null, x:0, y:0, max:40};

function updateLeftStick(x,y){ leftStickEl.style.left=`${35+x}px`; leftStickEl.style.top=`${35+y}px`; }
function resetLeftStick(){ updateLeftStick(0,0); }

function getTouchOffset(touch){
  const rect=leftJoyEl.getBoundingClientRect();
  const cx=rect.left+rect.width/2;
  const cy=rect.top+rect.height/2;
  let dx=touch.clientX-cx;
  let dy=touch.clientY-cy;
  const dist=Math.sqrt(dx*dx+dy*dy);
  if(dist>leftJoy.max){ const s=leftJoy.max/dist; dx*=s; dy*=s; }
  return {x:dx, y:dy};
}

leftJoyEl.addEventListener("touchstart", e=>{
  e.preventDefault();
  for(const t of e.changedTouches){
    if(!leftJoy.active && t.clientX<window.innerWidth/2){
      leftJoy.active=true;
      leftJoy.id=t.identifier;
      const o=getTouchOffset(t);
      leftJoy.x=o.x; leftJoy.y=o.y;
      updateLeftStick(leftJoy.x,leftJoy.y);
    }
  }
},{passive:false});

leftJoyEl.addEventListener("touchmove", e=>{
  e.preventDefault();
  for(const t of e.changedTouches){
    if(leftJoy.active && t.identifier===leftJoy.id){
      const o=getTouchOffset(t);
      leftJoy.x=o.x; leftJoy.y=o.y;
      updateLeftStick(leftJoy.x,leftJoy.y);
    }
  }
},{passive:false});

function endLeftTouch(e){
  e.preventDefault();
  for(const t of e.changedTouches){
    if(t.identifier===leftJoy.id){
      leftJoy.active=false; leftJoy.id=null; leftJoy.x=0; leftJoy.y=0;
      resetLeftStick();
    }
  }
}
leftJoyEl.addEventListener("touchend", endLeftTouch, {passive:false});
leftJoyEl.addEventListener("touchcancel", endLeftTouch, {passive:false});

// ---------- Right side touch look ----------
let touchLook={active:false, id:null, lastX:0, lastY:0};

document.addEventListener("touchstart", e=>{
  for(const t of e.changedTouches){
    if(t.clientX>=window.innerWidth/2 && !touchLook.active){
      touchLook.active=true;
      touchLook.id=t.identifier;
      touchLook.lastX=t.clientX;
      touchLook.lastY=t.clientY;
    }
  }
},{passive:false});

document.addEventListener("touchmove", e=>{
  for(const t of e.changedTouches){
    if(t.identifier===touchLook.id){
      const dx=t.clientX-touchLook.lastX;
      const dy=t.clientY-touchLook.lastY;
      camYaw-=dx*0.003;
      camPitch+=dy*0.003;
      camPitch=Math.max(-1.2, Math.min(0.4, camPitch));
      touchLook.lastX=t.clientX;
      touchLook.lastY=t.clientY;
    }
  }
},{passive:false});

document.addEventListener("touchend", e=>{
  for(const t of e.changedTouches){
    if(t.identifier===touchLook.id) touchLook.active=false;
  }
},{passive:false});
document.addEventListener("touchcancel", e=>{
  for(const t of e.changedTouches){
    if(t.identifier===touchLook.id) touchLook.active=false;
  }
},{passive:false});

// ---------- Mobile Sprint Button ----------
const sprintBtn=document.getElementById("sprintBtn");
let sprintTouch={active:false, id:null};

sprintBtn.addEventListener("touchstart", e=>{
  e.preventDefault();
  const t=e.changedTouches[0];
  sprintTouch.active=true;
  sprintTouch.id=t.identifier;
  sprintBtn.classList.add("active");
},{passive:false});

function endSprintTouch(e){
  for(const t of e.changedTouches){
    if(t.identifier===sprintTouch.id){
      sprintTouch.active=false;
      sprintTouch.id=null;
      sprintBtn.classList.remove("active");
    }
  }
}

sprintBtn.addEventListener("touchend", endSprintTouch, {passive:false});
sprintBtn.addEventListener("touchcancel", endSprintTouch, {passive:false});

// ---------- Animations ----------
const clock=new THREE.Clock();
const moveSpeed=5;
const sprintSpeed=8;

function normalizeAngle(a){ return Math.atan2(Math.sin(a),Math.cos(a)); }

function setAnim(target){
  if(!idleAction||!walkAction||currentAnim===target) return;
  const outgoing = currentAnim==='idle'?idleAction:currentAnim==='walk'?walkAction:runAction;

  if(target==="run" && runAction){
    outgoing.fadeOut(0.2);
    runAction.reset().fadeIn(0.2).play();
    currentAnim="run";
  }
  else if(target==="walk"){
    outgoing.fadeOut(0.2);
    walkAction.reset().fadeIn(0.2).play();
    currentAnim="walk";
  }
  else if(target==="idle"){
    outgoing.fadeOut(0.2);
    idleAction.reset().fadeIn(0.2).play();
    currentAnim="idle";
  }
}

// ---------- Main Loop ----------
function animate(){
  requestAnimationFrame(animate);
  const dt=clock.getDelta();
  if(mixer) mixer.update(dt);

  updateGamepadInput();

  fpsCounter++;
  if(fpsCounter%10===0) fpsDisplay=Math.round(1/dt);

  if(model){
    let forward=(keys.KeyW?1:0)+(keys.KeyS?-1:0);
    let sideways=(keys.KeyD?1:0)+(keys.KeyA?-1:0);

    // Combine PC sprint, mobile sprint, gamepad sprint
    isSprinting =
      (
        keys.ShiftLeft ||
        keys.ShiftRight ||
        sprintTouch.active
      ) &&
      (Math.abs(forward)>0 || Math.abs(sideways)>0);

    if(leftJoy.active){
      forward=-leftJoy.y/leftJoy.max;
      sideways=leftJoy.x/leftJoy.max;
      if(Math.abs(forward)<0.05) forward=0;
      if(Math.abs(sideways)<0.05) sideways=0;
    }

    if(gamepad.active){
      const [lx,ly,rx,ry] = [...gamepad.active.axes];
      const dz=settings.gamepadDeadzone;

      const lmag=Math.sqrt(lx*lx+ly*ly);
      if(lmag>dz){
        const n=(lmag-dz)/(1-dz);
        forward=-ly/lmag*n;
        sideways=lx/lmag*n;
      }

      const rmag=Math.sqrt(rx*rx+ry*ry);
      if(rmag>dz){
        const n=(rmag-dz)/(1-dz);
        camYaw-=rx*n*0.06*settings.gamepadSensitivity;
        camPitch+=ry*n*0.06*settings.gamepadSensitivity;
        camPitch=Math.max(-1.2,Math.min(0.4,camPitch));
      }
    }

    const moving=Math.abs(forward)>0 || Math.abs(sideways)>0;
    if(moving){
      const camF=new THREE.Vector3(Math.sin(camYaw),0,Math.cos(camYaw));
      const camR=new THREE.Vector3(-Math.cos(camYaw),0,Math.sin(camYaw));
      let moveDir=new THREE.Vector3().addScaledVector(camF,forward).addScaledVector(camR,sideways);
      const mag=moveDir.length(); if(mag>1) moveDir.normalize();

      const targetRot=Math.atan2(moveDir.x, moveDir.z)+Math.PI;
      let rotDiff=normalizeAngle(targetRot-playerState.rot);
      playerState.rot+=rotDiff*0.2;
      playerState.rot=normalizeAngle(playerState.rot);
      model.rotation.y=playerState.rot;

      const speed=isSprinting?sprintSpeed:moveSpeed;
      playerState.pos.add(moveDir.multiplyScalar(speed*dt));
      model.position.copy(playerState.pos);

      if(isSprinting) setAnim("run");
      else setAnim("walk");
      playerState.moving=true;
    }
    else {
      setAnim("idle");
      playerState.moving=false;
      isSprinting=false;
    }

    const camX=playerState.pos.x-Math.sin(camYaw)*camDist;
    const camZ=playerState.pos.z-Math.cos(camYaw)*camDist;
    const camY=playerState.pos.y+camHeight+Math.sin(camPitch)*camDist;
    camera.position.set(camX,camY,camZ);
    camera.lookAt(playerState.pos.x,playerState.pos.y+2,playerState.pos.z);
  }

  renderer.render(scene,camera);
  hudState.gamepad=!!gamepad.active;
  updateHud();
}
animate();

// ---------- Resize ----------
window.addEventListener("resize", ()=>{
  renderer.setSize(window.innerWidth,window.innerHeight);
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
});

updateLeftStick(0,0);
</script>
</body>
</html>
