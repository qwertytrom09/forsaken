<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Multiplayer WebRTC + GLB Avatars (Roblox-style)</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<style>
/* (same styles as your original file — omitted here for brevity; use the same CSS you already had) */
html, body {margin:0; height:100%; overflow:hidden; background:#0e0f12; color:white; -webkit-user-select:none; user-select:none; touch-action:none;}
#scene {width:100%; height:100%; display:block; touch-action:none;}
#loading {position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); color:#77c0ff; font-size:20px;}
#hud {position:absolute; top:20px; left:20px; color:#77c0ff; font-size:14px; background:rgba(0,0,0,0.4); padding:6px 10px; border-radius:6px; z-index:30;}
#shiftLockIndicator {position:absolute; top:20px; right:120px; z-index:31; background:rgba(13,16,24,0.85); border:1px solid rgba(119,192,255,0.3); color:#9fd0ff; padding:7px 14px; border-radius:999px; font-size:12px; letter-spacing:0.3px; box-shadow:0 6px 20px rgba(0,0,0,0.4); transition:background 0.3s ease, border-color 0.3s ease, color 0.3s ease, transform 0.2s ease;}
#shiftLockIndicator.active {background:rgba(119,192,255,0.2); border-color:rgba(119,192,255,0.8); color:#fff; transform:translateY(-1px);}

/* Left joystick */
#leftJoy {
  position:absolute; left:40px; bottom:40px;
  width:120px; height:120px;
  border-radius:50%; background: rgba(255,255,255,0.12); border:2px solid rgba(255,255,255,0.25);
  touch-action:none; z-index:20;
}
#leftJoy .stick {
  position:absolute; width:50px; height:50px; border-radius:50%; background: rgba(255,255,255,0.35);
  left:35px; top:35px;
  touch-action:none;
}
#touch-hint {
  position:absolute; left:50%; bottom:18px; transform:translateX(-50%);
  color:rgba(119,192,255,0.9); font-size:12px;
  background: rgba(0,0,0,0.35); padding:6px 10px; border-radius:8px; z-index:20;
}

/* Sprint Button (Mobile) */
#sprintBtn {
  position: absolute;
  right: 40px;
  bottom: 40px;
  width: 90px;
  height: 90px;
  border-radius: 50%;
  background: rgba(255,255,255,0.12);
  border: 2px solid rgba(255,255,255,0.25);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  color: #77c0ff;
  z-index: 25;
  user-select: none;
  touch-action: none;
  transition: background 0.15s, transform 0.1s;
}
#sprintBtn.active {
  background: rgba(119,192,255,0.28);
  transform: scale(1.08);
}

/* Settings menu truncated — reuse earlier styles */
#settingsBtn {
  position:absolute; top:20px; right:20px; z-index:31;
  background:rgba(119,192,255,0.2); border:1px solid rgba(119,192,255,0.5);
  color:#77c0ff; padding:8px 12px; border-radius:6px; cursor:pointer; font-size:12px;
  transition:transform 0.2s ease, background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
  box-shadow:0 8px 18px rgba(119,192,255,0.25);
}
#settingsBtn:hover { background:rgba(119,192,255,0.4); border-color:rgba(119,192,255,0.8); transform:translateY(-1px) scale(1.02); box-shadow:0 12px 28px rgba(119,192,255,0.35); }

#settingsOverlay {
  position:fixed; top:0; left:0; right:0; bottom:0;
  background:rgba(0,0,0,0.7); z-index:100; backdrop-filter:blur(6px);
  display:flex; align-items:center; justify-content:center;
  opacity:0; visibility:hidden; pointer-events:none;
  transition:opacity 0.35s ease, visibility 0s linear 0.35s;
}
#settingsOverlay.visible {
  opacity:1; visibility:visible; pointer-events:auto;
  transition:opacity 0.35s ease;
}
#settingsMenu {
  position:relative;
  background:rgba(20,22,28,0.95); border:2px solid rgba(119,192,255,0.3);
  padding:30px; border-radius:12px; max-width:400px; width:90%;
  box-shadow:0 8px 32px rgba(0,0,0,0.5);
  transform:translateY(20px) scale(0.96);
  opacity:0;
  transition:transform 0.4s cubic-bezier(0.16,1,0.3,1), opacity 0.3s ease;
}
#settingsOverlay.visible #settingsMenu { transform:translateY(0) scale(1); opacity:1; }
#settingsMenu h2 {
  margin:0 0 20px 0; color:#77c0ff; font-size:18px;
}
.setting-row {
  margin-bottom:16px; display:flex; justify-content:space-between; align-items:center;
}
.setting-row label { color:#aaa; font-size:12px; }
.setting-row input[type="range"] {
  width:60%; cursor:pointer;
}
.setting-row input[type="checkbox"] {
  cursor:pointer; width:18px; height:18px;
}
.setting-row select {
  background:rgba(255,255,255,0.08); border:1px solid rgba(119,192,255,0.3);
  color:#77c0ff; padding:6px 8px; border-radius:4px; cursor:pointer; font-size:12px;
}
#settingsMenu button {
  background:rgba(119,192,255,0.2); border:1px solid rgba(119,192,255,0.5);
  color:#77c0ff; padding:8px 12px; border-radius:6px; cursor:pointer; margin-right:8px;
  transition:all 0.2s; font-size:12px;
}
#settingsMenu button:hover { background:rgba(119,192,255,0.4); }
#settingsMenu .button-group {
  margin-top:20px; display:flex; justify-content:flex-end;
}
</style>

<script type="importmap">
{
  "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" }
}
</script>
</head>
<body>
<canvas id="scene"></canvas>
<div id="loading">Loading player…</div>
<div id="hud">Right-click + drag to rotate camera | WASD to move</div>
<button id="settingsBtn">⚙ Settings</button>
<div id="shiftLockIndicator">Ctrl Lock: Off</div>

<!-- Left joystick -->
<div id="leftJoy">
  <div class="stick" id="leftStick"></div>
</div>

<!-- Sprint Button (Mobile) -->
<div id="sprintBtn">Sprint</div>

<div id="touch-hint">Left: move • Right: look</div>

<!-- Settings menu -->
<div id="settingsOverlay">
  <div id="settingsMenu">
    <h2>Settings</h2>
    <div class="setting-row">
      <label>Mouse Sensitivity</label>
      <input type="range" id="mouseSensitivity" min="0.5" max="3" step="0.1" value="1">
    </div>
    <div class="setting-row">
      <label>Gamepad Deadzone</label>
      <input type="range" id="gamepadDeadzone" min="0" max="0.5" step="0.05" value="0.1">
    </div>
    <div class="setting-row">
      <label>Gamepad Sensitivity</label>
      <input type="range" id="gamepadSensitivity" min="0.5" max="3" step="0.1" value="1">
    </div>
    <div class="setting-row">
      <label>Graphics Quality</label>
      <select id="graphicsQuality">
        <option value="low">Low</option>
        <option value="medium" selected>Medium</option>
        <option value="high">High</option>
      </select>
    </div>
    <div class="setting-row">
      <label>Show FPS</label>
      <input type="checkbox" id="showFPS">
    </div>
    <div class="button-group">
      <button id="settingsClose">Close</button>
    </div>
  </div>
</div>

<script type="module">
import * as THREE from "three";
import { GLTFLoader } from "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js";

// Firebase (modular) for signaling + presence
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
import { getDatabase, ref, push, onChildAdded, onChildRemoved, set, update, onDisconnect, remove } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-database.js";

// ------------------- Config (your Firebase config) -------------------
const firebaseConfig = {
  apiKey: "AIzaSyCYqXADT96Ag6sxR82-5dBl1_3GaZRt_68",
  authDomain: "fors-7ee2c.firebaseapp.com",
  databaseURL: "https://fors-7ee2c-default-rtdb.firebaseio.com",
  projectId: "fors-7ee2c",
  storageBucket: "fors-7ee2c.firebasestorage.app",
  messagingSenderId: "980730651454",
  appId: "1:980730651454:web:97dce0fd4b5959eaaa826f",
  measurementId: "G-KWKKQ473PP"
};
const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

// ---------- HUD, settings, UI (same as before) ----------
const hud=document.getElementById('hud');
const shiftLockIndicator=document.getElementById('shiftLockIndicator');
const settingsOverlay=document.getElementById('settingsOverlay');
const baseHudMessage='Right-click + drag to rotate camera | WASD to move | Hold Shift to sprint | Press Ctrl for Ctrl Lock';
const hudState={gamepad:false};
let shiftLockEnabled=false;
let fpsCounter=0, fpsDisplay=0;
let isSprinting=false;

const settings = {
  mouseSensitivity: 1,
  gamepadDeadzone: 0.1,
  gamepadSensitivity: 1,
  graphicsQuality: 'medium',
  showFPS: false
};

function updateHud(){
  if(settings.showFPS){
    hud.textContent=`FPS: ${fpsDisplay} | Right-click + drag to rotate camera | WASD to move | Gamepad: ${hudState.gamepad?'✓':'✗'} | Ctrl Lock: ${shiftLockEnabled?'On':'Off'} | Sprint: ${isSprinting?'On':'Off'}`;
  } else {
    hud.textContent=`${baseHudMessage} | Ctrl Lock: ${shiftLockEnabled?'On':'Off'}`;
  }
}

function updateSettingsUI(){
  document.getElementById('mouseSensitivity').value = settings.mouseSensitivity;
  document.getElementById('gamepadDeadzone').value = settings.gamepadDeadzone;
  document.getElementById('gamepadSensitivity').value = settings.gamepadSensitivity;
  document.getElementById('graphicsQuality').value = settings.graphicsQuality;
  document.getElementById('showFPS').checked = settings.showFPS;
}

document.getElementById('mouseSensitivity').addEventListener('change', e=>{ settings.mouseSensitivity=parseFloat(e.target.value); });
document.getElementById('gamepadDeadzone').addEventListener('change', e=>{ settings.gamepadDeadzone=parseFloat(e.target.value); });
document.getElementById('gamepadSensitivity').addEventListener('change', e=>{ settings.gamepadSensitivity=parseFloat(e.target.value); });
document.getElementById('graphicsQuality').addEventListener('change', e=>{ settings.graphicsQuality=e.target.value; });
document.getElementById('showFPS').addEventListener('change', e=>{ settings.showFPS=e.target.checked; updateHud(); });

document.getElementById('settingsBtn').addEventListener('click', ()=>settingsOverlay.classList.add('visible'));
document.getElementById('settingsClose').addEventListener('click', ()=>settingsOverlay.classList.remove('visible'));

settingsOverlay.addEventListener('click', e=>{
  if(e.target===settingsOverlay) settingsOverlay.classList.remove('visible');
});

updateSettingsUI();
updateHud();

// Hide joystick on PC
if (!('ontouchstart' in window)) {
  document.getElementById('leftJoy').style.display = 'none';
  document.getElementById('touch-hint').style.display = 'none';
  document.getElementById('sprintBtn').style.display = 'none';
}

// ------------------- Three.js scene (same as your original) -------------------
const canvas = document.getElementById("scene");
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
renderer.setSize(window.innerWidth, window.innerHeight);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x1a1d22);
const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight,0.1,500);

scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1));
const light = new THREE.DirectionalLight(0xffffff,1.4);
light.position.set(5,10,7);
scene.add(light);

const ground = new THREE.Mesh(new THREE.PlaneGeometry(100,100), new THREE.MeshStandardMaterial({color:0x202226}));
ground.rotation.x=-Math.PI/2;
scene.add(ground);

// sample level geometry (same)
const geometry = new THREE.BoxGeometry(8,3,8);
const material = new THREE.MeshStandardMaterial({color:0x3a3d42});
const rock1 = new THREE.Mesh(geometry, material); rock1.position.set(15, 1.5, 20); scene.add(rock1);
const rock2 = new THREE.Mesh(geometry, material); rock2.position.set(-20, 1.5, 15); scene.add(rock2);
const rock3 = new THREE.Mesh(geometry, material); rock3.position.set(0, 1.5, -25); scene.add(rock3);

// ------------------- Local player & input (same as your existing code) -------------------
let model, mixer, idleAction, walkAction, runAction;
const loader = new GLTFLoader();
const playerState = { pos:new THREE.Vector3(0,0,0), rot:0, moving:false, lastSendVec:new THREE.Vector3() };
let currentAnim = 'idle';
function loadPlayer(){
  loader.load("./model/idle.glb", idleGLB=>{
    model=idleGLB.scene;
    model.scale.set(0.35,0.35,0.35);
    model.rotation.y=Math.PI;
    scene.add(model);
    mixer=new THREE.AnimationMixer(model);
    idleAction=mixer.clipAction(idleGLB.animations[0]);
    idleAction.play();

    loader.load("./model/walk.glb", walkGLB=>{
      walkAction=mixer.clipAction(walkGLB.animations[0]);
      walkAction.timeScale=2;

      loader.load("./model/run.glb", runGLB=>{
        runAction=mixer.clipAction(runGLB.animations[0]);
        runAction.timeScale=3.3;
        document.getElementById("loading").style.display="none";
      }, undefined, err=>{
        console.log("Run animation missing, using walk.");
        runAction = walkAction;
        document.getElementById("loading").style.display="none";
      });

    }, undefined, err=>{
      walkAction = idleAction;
      runAction = idleAction;
      document.getElementById("loading").style.display="none";
    });

  }, undefined, err=>{
    console.error("Model load error:", err);
    const fallbackGeom=new THREE.CapsuleGeometry(0.5,1,4,8);
    const fallbackMat=new THREE.MeshStandardMaterial({color:0x77c0ff});
    model=new THREE.Mesh(fallbackGeom,fallbackMat);
    model.position.copy(playerState.pos);
    scene.add(model);
    setTimeout(()=>document.getElementById("loading").style.display="none",1000);
  });
}
loadPlayer();

let camYaw=0, camPitch=-0.35, camDist=6, camHeight=3;
const keys = {KeyW:false, KeyA:false, KeyS:false, KeyD:false, ShiftLeft:false, ShiftRight:false};
window.addEventListener("keydown",e=>{ if(keys[e.code]!==undefined) keys[e.code]=true; if(e.code.includes("Control")&&!e.repeat) toggleShiftLock(); });
window.addEventListener("keyup",e=>{ if(keys[e.code]!==undefined) keys[e.code]=false; });
let dragging=false;
document.addEventListener("contextmenu", e=>e.preventDefault());
document.addEventListener("mousedown", e=>{ if(e.button===2) dragging=true; });
document.addEventListener("mouseup", ()=>dragging=false);
document.addEventListener("mousemove", e=>{
  if(!dragging && !shiftLockEnabled) return;
  camYaw -= e.movementX*0.003*settings.mouseSensitivity;
  camPitch += e.movementY*0.003*settings.mouseSensitivity;
  camPitch=Math.max(-1.2, Math.min(0.4, camPitch));
});
function setShiftLockState(state){
  shiftLockEnabled=state;
  shiftLockIndicator.textContent=state?'Ctrl Lock: On':'Ctrl Lock: Off';
  shiftLockIndicator.classList.toggle('active', state);
  updateHud();
}
function toggleShiftLock(){
  if(!canvas.requestPointerLock) return;
  if(document.pointerLockElement===canvas) document.exitPointerLock();
  else canvas.requestPointerLock();
}
document.addEventListener("pointerlockchange", ()=>{ setShiftLockState(document.pointerLockElement===canvas); if(!document.pointerLockElement) dragging=false; });
document.addEventListener("pointerlockerror", ()=>setShiftLockState(false));

// left joystick + touch look + sprint button (same as before)...
const gamepad={active:null};
function updateGamepadInput(){ const pads=navigator.getGamepads(); if(!pads[0]){gamepad.active=null; return;} gamepad.active=pads[0]; }
window.addEventListener("gamepadconnected", e=>console.log("Gamepad:",e.gamepad.id));
window.addEventListener("gamepaddisconnected", e=>{ if(gamepad.active?.index===e.gamepad.index) gamepad.active=null; });

const leftJoyEl=document.getElementById("leftJoy");
const leftStickEl=document.getElementById("leftStick");
const leftJoy={active:false, id:null, x:0, y:0, max:40};
function updateLeftStick(x,y){ leftStickEl.style.left=`${35+x}px`; leftStickEl.style.top=`${35+y}px`; }
function resetLeftStick(){ updateLeftStick(0,0); }
function getTouchOffset(touch){
  const rect=leftJoyEl.getBoundingClientRect();
  const cx=rect.left+rect.width/2;
  const cy=rect.top+rect.height/2;
  let dx=touch.clientX-cx; let dy=touch.clientY-cy;
  const dist=Math.sqrt(dx*dx+dy*dy);
  if(dist>leftJoy.max){ const s=leftJoy.max/dist; dx*=s; dy*=s; }
  return {x:dx, y:dy};
}
leftJoyEl.addEventListener("touchstart", e=>{ e.preventDefault(); for(const t of e.changedTouches){ if(!leftJoy.active && t.clientX<window.innerWidth/2){ leftJoy.active=true; leftJoy.id=t.identifier; const o=getTouchOffset(t); leftJoy.x=o.x; leftJoy.y=o.y; updateLeftStick(leftJoy.x,leftJoy.y); } } },{passive:false});
leftJoyEl.addEventListener("touchmove", e=>{ e.preventDefault(); for(const t of e.changedTouches){ if(leftJoy.active && t.identifier===leftJoy.id){ const o=getTouchOffset(t); leftJoy.x=o.x; leftJoy.y=o.y; updateLeftStick(leftJoy.x,leftJoy.y); } } },{passive:false});
function endLeftTouch(e){ e.preventDefault(); for(const t of e.changedTouches){ if(t.identifier===leftJoy.id){ leftJoy.active=false; leftJoy.id=null; leftJoy.x=0; leftJoy.y=0; resetLeftStick(); } } }
leftJoyEl.addEventListener("touchend", endLeftTouch, {passive:false});
leftJoyEl.addEventListener("touchcancel", endLeftTouch, {passive:false});

let touchLook={active:false, id:null, lastX:0, lastY:0};
document.addEventListener("touchstart", e=>{ for(const t of e.changedTouches){ if(t.clientX>=window.innerWidth/2 && !touchLook.active){ touchLook.active=true; touchLook.id=t.identifier; touchLook.lastX=t.clientX; touchLook.lastY=t.clientY; } } },{passive:false});
document.addEventListener("touchmove", e=>{ for(const t of e.changedTouches){ if(t.identifier===touchLook.id){ const dx=t.clientX-touchLook.lastX; const dy=t.clientY-touchLook.lastY; camYaw-=dx*0.003; camPitch+=dy*0.003; camPitch=Math.max(-1.2, Math.min(0.4, camPitch)); touchLook.lastX=t.clientX; touchLook.lastY=t.clientY; } } },{passive:false});
document.addEventListener("touchend", e=>{ for(const t of e.changedTouches){ if(t.identifier===touchLook.id) touchLook.active=false; } },{passive:false});
document.addEventListener("touchcancel", e=>{ for(const t of e.changedTouches){ if(t.identifier===touchLook.id) touchLook.active=false; } },{passive:false});

const sprintBtn=document.getElementById("sprintBtn");
let sprintTouch={active:false, id:null};
sprintBtn.addEventListener("touchstart", e=>{ e.preventDefault(); const t=e.changedTouches[0]; sprintTouch.active=true; sprintTouch.id=t.identifier; sprintBtn.classList.add("active"); },{passive:false});
function endSprintTouch(e){ for(const t of e.changedTouches){ if(t.identifier===sprintTouch.id){ sprintTouch.active=false; sprintTouch.id=null; sprintBtn.classList.remove("active"); } } }
sprintBtn.addEventListener("touchend", endSprintTouch, {passive:false});
sprintBtn.addEventListener("touchcancel", endSprintTouch, {passive:false});

// animation helpers
const clock=new THREE.Clock();
const moveSpeed=5;
const sprintSpeed=8;
function normalizeAngle(a){ return Math.atan2(Math.sin(a),Math.cos(a)); }
function setAnim(target){
  if(!idleAction||!walkAction||currentAnim===target) return;
  const outgoing = currentAnim==='idle'?idleAction:currentAnim==='walk'?walkAction:runAction;
  if(target==="run" && runAction){ outgoing.fadeOut(0.2); runAction.reset().fadeIn(0.1).play(); currentAnim="run"; }
  else if(target==="walk"){ outgoing.fadeOut(0.2); walkAction.reset().fadeIn(0.2).play(); currentAnim="walk"; }
  else if(target==="idle"){ outgoing.fadeOut(0.2); idleAction.reset().fadeIn(0.2).play(); currentAnim="idle"; }
}

// ------------------- Multiplayer via WebRTC (signaling in Firebase) -------------------

// STUN servers (modify if you have TURN for NAT traversal in production)
const rtcConfig = { iceServers:[ { urls: "stun:stun.l.google.com:19302" } ] };

// IDs and DB refs
const playerId = (typeof crypto !== 'undefined' && crypto.randomUUID) ? crypto.randomUUID() : ('p_' + Math.random().toString(36).slice(2,9));
const playersRef = ref(db, 'players');         // presence
const signalsRootRef = ref(db, 'signals');     // signaling channel root

// local peer objects: peerId -> { pc, dc, state }
const peers = {};

// remote players (visuals): id -> { model?, mesh, prevState, lastState, lastRecvTs }
const remotePlayers = Object.create(null);

// convenience GLB paths (we'll try to load these for remote avatars)
const remoteModelPaths = {
  idle: "./model/idle.glb",
  walk: "./model/walk.glb",
  run:  "./model/run.glb"
};

// create fallback capsule for remote players
function createFallbackMesh(){ const g=new THREE.CapsuleGeometry(0.45, 1.0, 4, 8); return new THREE.Mesh(g, new THREE.MeshStandardMaterial({color:0xffb86b})); }

// load remote avatar GLB (attempt to load same model used locally)
async function loadRemoteAvatar(id){
  // If already created, return
  if(remotePlayers[id] && remotePlayers[id].model) return remotePlayers[id].model;
  const gltfLoad = (path) => new Promise((resolve, reject)=> loader.load(path, resolve, undefined, reject));
  try{
    // Attempt to load idle model, and also try to keep walk/run animations if present.
    const idleG = await gltfLoad(remoteModelPaths.idle);
    const remoteModel = idleG.scene.clone();
    remoteModel.scale.set(0.35,0.35,0.35);
    scene.add(remoteModel);
    // store animations if present (optional)
    remotePlayers[id].model = remoteModel;
    remotePlayers[id].mixer = idleG.animations && idleG.animations.length ? new THREE.AnimationMixer(remoteModel) : null;
    if(remotePlayers[id].mesh){ scene.remove(remotePlayers[id].mesh); remotePlayers[id].mesh=null; }
    return remoteModel;
  }catch(err){
    console.warn("Remote GLB load failed for", id, err);
    // fallback to capsule mesh
    if(!remotePlayers[id].mesh){
      remotePlayers[id].mesh = createFallbackMesh();
      scene.add(remotePlayers[id].mesh);
    }
    return null;
  }
}

// Signaling helpers using Firebase push to target's signal queue
function sendSignalTo(targetId, payload){
  // payload: { from, type, sdp?, candidate? }
  const targetRef = ref(db, `signals/${targetId}`);
  // push the msg
  push(targetRef, payload).catch(err => console.warn("Signal push failed", err));
}

// Listen for signal messages addressed to me
const mySignalsRef = ref(db, `signals/${playerId}`);
onChildAdded(mySignalsRef, async (snap) => {
  const msg = snap.val();
  if(!msg || !msg.from) return;
  const from = msg.from;
  // If initiator sent offer:
  if(msg.type === 'offer'){
    // create a peer connection if not exists
    if(peers[from] && peers[from].pc) {
      // Already exists: ignore or setRemoteDescription update
    } else {
      await createPeerAsReceiver(from);
    }
    const pc = peers[from].pc;
    try{
      await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      sendSignalTo(from, { from: playerId, type: 'answer', sdp: pc.localDescription });
    }catch(err){ console.error("Failed handle offer", err); }
  }
  else if(msg.type === 'answer'){
    const pc = peers[from]?.pc;
    if(!pc) return;
    try{
      await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
    }catch(err){ console.warn("Failed to set remote description (answer)", err); }
  }
  else if(msg.type === 'ice'){
    const pc = peers[from]?.pc;
    if(!pc) return;
    try{
      await pc.addIceCandidate(msg.candidate);
    }catch(err){ console.warn("Failed to add ICE candidate", err); }
  }
  // remove processed signal to keep DB clean
  remove(snap.ref).catch(()=>{});
});

// create a new RTCPeerConnection as caller for a given remoteId
async function createPeerAsCaller(remoteId){
  if(peers[remoteId]) return peers[remoteId];
  const pc = new RTCPeerConnection(rtcConfig);
  peers[remoteId] = { pc, dc: null, connected:false };
  // data channel for positional updates:
  const dc = pc.createDataChannel('pos', { ordered: true });
  peers[remoteId].dc = dc;

  dc.onopen = () => { peers[remoteId].connected = true; console.log("DataChannel open to", remoteId); };
  dc.onclose = () => { peers[remoteId].connected = false; console.log("DataChannel closed for", remoteId); };
  dc.onmessage = (ev) => { handleRemoteData(remoteId, ev.data); };

  pc.onicecandidate = (evt) => {
    if(evt.candidate) sendSignalTo(remoteId, { from: playerId, type:'ice', candidate: evt.candidate });
  };

  pc.onconnectionstatechange = ()=>{
    if(pc.connectionState === 'disconnected' || pc.connectionState === 'failed' || pc.connectionState === 'closed'){
      cleanupPeer(remoteId);
    }
  };

  // also handle remote datachannels (rare for caller but keep)
  pc.ondatachannel = (e)=>{ const channel = e.channel; channel.onmessage = (ev)=> handleRemoteData(remoteId, ev.data); };

  // create offer
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  // send offer via firebase to remote's signals queue
  sendSignalTo(remoteId, { from: playerId, type:'offer', sdp: pc.localDescription });
  return peers[remoteId];
}

// create a new RTCPeerConnection as receiver (when an offer arrives)
async function createPeerAsReceiver(remoteId){
  if(peers[remoteId]) return peers[remoteId];
  const pc = new RTCPeerConnection(rtcConfig);
  peers[remoteId] = { pc, dc: null, connected:false };

  pc.ondatachannel = (e) => {
    const channel = e.channel;
    peers[remoteId].dc = channel;
    channel.onopen = ()=> { peers[remoteId].connected = true; console.log("DataChannel opened (recv) to", remoteId); };
    channel.onclose = ()=> { peers[remoteId].connected = false; console.log("DataChannel closed (recv) for", remoteId); };
    channel.onmessage = (ev)=> handleRemoteData(remoteId, ev.data);
  };

  pc.onicecandidate = (evt)=> { if(evt.candidate) sendSignalTo(remoteId, { from: playerId, type:'ice', candidate: evt.candidate }); };
  pc.onconnectionstatechange = ()=> { if(pc.connectionState === 'disconnected' || pc.connectionState === 'failed' || pc.connectionState === 'closed'){ cleanupPeer(remoteId); } };

  return peers[remoteId];
}

// cleanup peer connection and remote player visual
function cleanupPeer(remoteId){
  const p = peers[remoteId];
  if(p){
    try { p.pc.close(); } catch(e) {}
    if(p.dc && p.dc.close) try { p.dc.close(); } catch(e){}
    delete peers[remoteId];
  }
  const rp = remotePlayers[remoteId];
  if(rp){
    if(rp.model) { scene.remove(rp.model); rp.model=null; }
    if(rp.mesh) { scene.remove(rp.mesh); rp.mesh=null; }
    delete remotePlayers[remoteId];
  }
  // Remove remote presence is handled by their own disconnect
}

// Handle data messages from a remote peer (stringified JSON)
function handleRemoteData(remoteId, data){
  let obj;
  try{ obj = JSON.parse(data); } catch(e){ console.warn("Bad JSON from", remoteId, e); return; }
  const ts = Date.now();
  if(!remotePlayers[remoteId]) {
    // Initialize remote player storage
    remotePlayers[remoteId] = {
      mesh: createFallbackMesh(),
      model: null,
      mixer: null,
      prevState: null,
      lastState: null,
      lastRecvTs: ts
    };
    scene.add(remotePlayers[remoteId].mesh);
    // try to load remote avatar GLB asynchronously
    loadRemoteAvatar(remoteId).then(()=>{/* done */});
  }
  const rp = remotePlayers[remoteId];

  // message expected: { pos:{x,y,z}, rot:number, anim:string, ts:number, vel?:{x,y,z} }
  const newState = {
    pos: new THREE.Vector3(obj.pos.x, obj.pos.y, obj.pos.z),
    rot: obj.rot,
    anim: obj.anim || 'idle',
    ts: obj.ts || Date.now(),
    vel: obj.vel ? new THREE.Vector3(obj.vel.x, obj.vel.y, obj.vel.z) : null
  };

  // Shift previous -> prevState, store lastState
  rp.prevState = rp.lastState ? { ...rp.lastState } : null;
  rp.lastState = newState;
  rp.lastRecvTs = ts;
}

// ------------------- Presence (announce & discover peers via Firebase presence list) -------------------
const localPlayerRef = ref(db, `players/${playerId}`);
async function announcePresence(){
  // write presence
  const payload = { id: playerId, ts: Date.now() };
  await set(localPlayerRef, payload).catch(err=>console.warn("presence set failed", err));
  // ensure removal on disconnect
  onDisconnect(localPlayerRef).remove();
}
announcePresence();

// Discover other players via playersRef and attempt P2P connects
onChildAdded(playersRef, (snap) => {
  const id = snap.key;
  if(id === playerId) return;
  // if peer doesn't already exist, start a caller to them
  if(!peers[id]) {
    // small timeout to avoid thundering - stagger initiations
    setTimeout(()=> {
      createPeerAsCaller(id).catch(err => console.warn("createPeerAsCaller error", err));
    }, Math.random()*400 + 50);
  }
});
onChildRemoved(playersRef, (snap) => {
  const id = snap.key;
  // cleanup peer & visuals
  cleanupPeer(id);
});

// ------------------- Outgoing state updates over data channels (throttled) -------------------
let lastSend = 0;
function buildOutgoingState(){
  // include pos, rot, anim, timestamp, and velocity (approx)
  const now = Date.now();
  // velocity estimation
  const vel = new THREE.Vector3();
  if(playerState.lastSendVec){
    vel.copy(playerState.pos).sub(playerState.lastSendVec).multiplyScalar(1000 / Math.max(1, now - (playerState.lastSendTs || now)));
  }
  playerState.lastSendVec = playerState.pos.clone();
  playerState.lastSendTs = now;

  return {
    pos: { x: playerState.pos.x, y: playerState.pos.y, z: playerState.pos.z },
    rot: playerState.rot,
    anim: currentAnim,
    ts: now,
    vel: { x: vel.x, y: vel.y, z: vel.z }
  };
}

// send to all connected peers
function broadcastState(){
  const now = performance.now();
  if(now - lastSend < 50) return; // 20Hz
  lastSend = now;
  const state = buildOutgoingState();
  const str = JSON.stringify(state);
  for(const id in peers){
    const p = peers[id];
    if(p && p.dc && p.dc.readyState === 'open'){
      try{ p.dc.send(str); }catch(e){ console.warn("Send failed to", id, e); }
    }
  }
}

// ------------------- Interpolation + Extrapolation for remote players -------------------
// We'll interpolate between prevState and lastState using timestamps.
// If last update is too old, extrapolate position by applying velocity for time delta.
function updateRemoteTransforms(dt){
  const now = Date.now();
  for(const id in remotePlayers){
    const rp = remotePlayers[id];
    if(!rp.lastState) continue;
    // If we have prevState, interpolate between them
    if(rp.prevState){
      const a = rp.prevState;
      const b = rp.lastState;
      const tNow = now;
      const duration = Math.max(1, (b.ts - a.ts)); // ms
      let alpha = (tNow - b.ts) / duration + 1; // predict slightly into future
      // clamp between 0 and 1 for interpolation; if >1 use extrapolation
      if(alpha < 0) alpha = 0;
      // apply slight lead to hide latency (prediction factor)
      const predictionLead = 0.08; // seconds
      alpha = alpha + predictionLead;
      // Lerp position
      const pos = new THREE.Vector3().lerpVectors(a.pos, b.pos, Math.min(1, alpha));
      // If alpha beyond 1, extrapolate using velocity if available
      if(alpha > 1 && b.vel){
        const extra = (alpha - 1) * (duration/1000);
        const extrap = new THREE.Vector3(b.vel.x, b.vel.y, b.vel.z).multiplyScalar(extra);
        pos.add(extrap);
      }
      // Apply to model or mesh
      if(rp.model){
        rp.model.position.copy(pos);
        // rotate smoothly
        const rotDiff = normalizeAngle(b.rot - rp.model.rotation.y);
        rp.model.rotation.y += rotDiff * Math.min(1, 6 * dt);
      } else if(rp.mesh){
        rp.mesh.position.copy(pos);
        const rotDiff = normalizeAngle(b.rot - rp.mesh.rotation.y);
        rp.mesh.rotation.y += rotDiff * Math.min(1, 6 * dt);
      }
    } else {
      // no prevState: directly set lastState, or use vel to extrapolate based on time since lastRecvTs
      const b = rp.lastState;
      let pos = b.pos.clone();
      const age = (now - b.ts)/1000;
      const maxExtrap = 0.35; // seconds
      if(age > 0.04 && b.vel) {
        const t = Math.min(age, maxExtrap);
        pos.add(new THREE.Vector3(b.vel.x, b.vel.y, b.vel.z).multiplyScalar(t));
      }
      if(rp.model) rp.model.position.copy(pos);
      else if(rp.mesh) rp.mesh.position.copy(pos);
      // rotation
      if(rp.model) rp.model.rotation.y = b.rot;
      else if(rp.mesh) rp.mesh.rotation.y = b.rot;
    }
  }
}

// ------------------- Main Loop (movement, send, interpolation) -------------------
function animate(){
  requestAnimationFrame(animate);
  const dt = clock.getDelta();
  if(mixer) mixer.update(dt);

  updateGamepadInput();
  fpsCounter++; if(fpsCounter%10===0) fpsDisplay=Math.round(1/dt);

  if(model){
    let forward=(keys.KeyW?1:0)+(keys.KeyS?-1:0);
    let sideways=(keys.KeyD?1:0)+(keys.KeyA?-1:0);

    isSprinting = (keys.ShiftLeft||keys.ShiftRight||sprintTouch.active) && (Math.abs(forward)>0 || Math.abs(sideways)>0);

    if (leftJoy.active) {
      let rawForward = -leftJoy.y / leftJoy.max;
      let rawSideways = leftJoy.x / leftJoy.max;
      const joyMoving = Math.abs(rawForward) > 0.01 || Math.abs(rawSideways) > 0.01;
      forward = Math.abs(rawForward) < 0.05 ? 0 : rawForward;
      sideways = Math.abs(rawSideways) < 0.05 ? 0 : rawSideways;
      if (joyMoving) {
        isSprinting = (keys.ShiftLeft || keys.ShiftRight || sprintTouch.active) && joyMoving;
      }
    }

    if(gamepad.active){
      const [lx,ly,rx,ry] = [...gamepad.active.axes];
      const dz=settings.gamepadDeadzone;
      const lmag=Math.sqrt(lx*lx+ly*ly);
      if(lmag>dz){
        const n=(lmag-dz)/(1-dz);
        forward=-ly/lmag*n;
        sideways=lx/lmag*n;
      }
      const rmag=Math.sqrt(rx*rx+ry*ry);
      if(rmag>dz){
        const n=(rmag-dz)/(1-dz);
        camYaw-=rx*n*0.06*settings.gamepadSensitivity;
        camPitch+=ry*n*0.06*settings.gamepadSensitivity;
        camPitch=Math.max(-1.2,Math.min(0.4,camPitch));
      }
    }

    const moving=Math.abs(forward)>0 || Math.abs(sideways)>0;
    if(moving){
      const camF=new THREE.Vector3(Math.sin(camYaw),0,Math.cos(camYaw));
      const camR=new THREE.Vector3(-Math.cos(camYaw),0,Math.sin(camYaw));
      let moveDir=new THREE.Vector3().addScaledVector(camF,forward).addScaledVector(camR,sideways);
      const mag=moveDir.length(); if(mag>1) moveDir.normalize();

      const targetRot=Math.atan2(moveDir.x, moveDir.z)+Math.PI;
      let rotDiff=normalizeAngle(targetRot-playerState.rot);
      playerState.rot+=rotDiff*0.2;
      playerState.rot=normalizeAngle(playerState.rot);
      model.rotation.y=playerState.rot;

      const speed=isSprinting?sprintSpeed:moveSpeed;
      playerState.pos.add(moveDir.multiplyScalar(speed*dt));
      model.position.copy(playerState.pos);

      if(isSprinting) setAnim("run");
      else setAnim("walk");
      playerState.moving=true;
    } else {
      setAnim("idle");
      playerState.moving=false;
      isSprinting=false;
    }

    const camX=playerState.pos.x-Math.sin(camYaw)*camDist;
    const camZ=playerState.pos.z-Math.cos(camYaw)*camDist;
    const camY=playerState.pos.y+camHeight+Math.sin(camPitch)*camDist;
    camera.position.set(camX,camY,camZ);
    camera.lookAt(playerState.pos.x,playerState.pos.y+2,playerState.pos.z);

    // Broadcast state via WebRTC datachannels
    broadcastState();
  }

  // update remote transforms based on interpolation/extrapolation
  updateRemoteTransforms(dt);

  renderer.render(scene,camera);
  hudState.gamepad=!!gamepad.active;
  updateHud();
}
animate();

// cleanup on unload
window.addEventListener('beforeunload', ()=> {
  try { remove(localPlayerRef); } catch(e){}
  // try to close peers
  for(const id in peers) cleanupPeer(id);
});

window.addEventListener("resize", ()=>{ renderer.setSize(window.innerWidth,window.innerHeight); camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); });
</script>
</body>
</html>
