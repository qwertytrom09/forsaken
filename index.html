<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>FBX Viewer – idle.fbx</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html, body {margin:0; height:100%; background:#0e0f12; color:#e6e7eb; font-family:sans-serif;}
    .app-header, .app-footer {padding:12px 16px; display:flex; gap:12px;}
    .canvas-wrap {position:relative; width:100%; height:calc(100vh - 96px);}
    #scene {width:100%; height:100%; display:block;}
    #loading {position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); color:#77c0ff;}
    #gui {position:absolute; top:10px; right:10px;}
  </style>
</head>
<body>
  <header class="app-header">
    <h1>FBX Viewer</h1>
    <p id="status">Loading idle.fbx…</p>
  </header>
  <main class="canvas-wrap">
    <canvas id="scene"></canvas>
    <div id="loading">Loading model… <span id="progress">0%</span></div>
    <div id="gui"></div>
  </main>
  <footer class="app-footer"><small>Three.js + FBXLoader</small></footer>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';
    import { FBXLoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/FBXLoader.js';
    import { RGBELoader } from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/RGBELoader.js';
    import { EffectComposer } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://unpkg.com/three@0.160.0/examples/jsm/postprocessing/UnrealBloomPass.js';
    import GUI from 'https://cdn.jsdelivr.net/npm/lil-gui@0.19/+esm';

    const canvas = document.getElementById('scene');
    const status = document.getElementById('status');
    const loadingDiv = document.getElementById('loading');

    // Renderer
    const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
    renderer.setSize(canvas.clientWidth, canvas.clientHeight, false);
    renderer.shadowMap.enabled = true;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;

    // Scene & Camera
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45,1,0.1,1000);
    camera.position.set(2.5,1.8,3.5);

    // Controls
    const controls = new OrbitControls(camera, canvas);
    controls.enableDamping = true;
    controls.target.set(0,1,0);

    // Lights
    scene.add(new THREE.HemisphereLight(0xffffff,0x404040,0.9));
    const dirLight = new THREE.DirectionalLight(0xffffff,1.3);
    dirLight.position.set(5,10,7.5);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // Ground
    const ground = new THREE.Mesh(new THREE.PlaneGeometry(20,20),
      new THREE.MeshStandardMaterial({color:0x202226}));
    ground.rotation.x = -Math.PI/2;
    ground.receiveShadow = true;
    scene.add(ground);

    // Environment map (optional HDR in assets/)
    new RGBELoader().setPath('assets/').load('studio.hdr',(tex)=>{
      tex.mapping = THREE.EquirectangularReflectionMapping;
      scene.environment = tex;
      scene.background = tex;
    });

    // Postprocessing
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene,camera));
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(canvas.clientWidth,canvas.clientHeight),0.4,0.4,0.85);
    composer.addPass(bloomPass);

    // FBX loader
    const loader = new FBXLoader();
    let mixer=null, actions={}, currentAction=null;
    loader.load('assets/idle.fbx',(obj)=>{
      loadingDiv.style.display='none';
      status.textContent='Model loaded';
      obj.traverse(c=>{if(c.isMesh)c.castShadow=true;});
      const box=new THREE.Box3().setFromObject(obj);
      const size=new THREE.Vector3(); box.getSize(size);
      const scale=1.5/Math.max(size.x,size.y,size.z);
      obj.scale.setScalar(scale);
      scene.add(obj);
      if(obj.animations.length>0){
        mixer=new THREE.AnimationMixer(obj);
        obj.animations.forEach(clip=>{actions[clip.name]=mixer.clipAction(clip);});
        currentAction=actions[Object.keys(actions)[0]];
        currentAction.play();
      }
      controls.target.copy(obj.position);
      controls.update();
    },(xhr)=>{
      document.getElementById('progress').textContent=((xhr.loaded/xhr.total)*100).toFixed(0)+'%';
    },(err)=>{status.textContent='Error loading FBX'; console.error(err);});

    // GUI
    const gui=new GUI({container:document.getElementById('gui')});
    const settings={autoRotate:false,exposure:1.0,bloomStrength:0.4,bloomThreshold:0.85,bloomRadius:0.4};
    gui.add(settings,'autoRotate');
    gui.add(settings,'exposure',0.1,2).onChange(v=>renderer.toneMappingExposure=v);
    gui.add(settings,'bloomStrength',0,2).onChange(v=>bloomPass.strength=v);
    gui.add(settings,'bloomThreshold',0,1).onChange(v=>bloomPass.threshold=v);
    gui.add(settings,'bloomRadius',0,2).onChange(v=>bloomPass.radius=v);
    const cameraPresets={Front:()=>camera.position.set(0,1.5,3),Side:()=>camera.position.set(3,1.5,0),Top:()=>camera.position.set(0,5,0)};
    gui.add(cameraPresets,'Front'); gui.add(cameraPresets,'Side'); gui.add(cameraPresets,'Top');
    function switchAnimation(name){if(actions[name]){if(currentAction)currentAction.stop(); currentAction=actions[name]; currentAction.reset().play();}}
    gui.add({animation:''},'animation',Object.keys(actions)).onChange(switchAnimation);

    // Resize
    function resizeRendererToDisplaySize(){
      const w=canvas.clientWidth,h=canvas.clientHeight;
      if(canvas.width!==w||canvas.height!==h){
        renderer.setSize(w,h,false);
        camera.aspect=w/h; camera.updateProjectionMatrix();
        composer.setSize(w,h);
      }
    }

    // Loop
    const clock=new THREE.Clock();
    renderer.setAnimationLoop(()=>{
      const delta=clock.getDelta();
      if(mixer)mixer.update(delta);
      controls.autoRotate=settings.autoRotate;
      controls.update();
      resizeRendererToDisplaySize();
      composer.render();
    });
  </script>
</body>
</html>
