<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js FBX Model Viewer</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for full-screen canvas display */
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
        }
        #scene-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            display: block;
        }
        .info-message {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
        }
    </style>
</head>
<body>

    <div id="scene-container">
        <!-- Canvas will be appended here by Three.js -->
    </div>

    <div id="message" class="info-message bg-yellow-500 text-gray-900 p-2 rounded shadow-lg text-sm md:text-base">
        Loading 3D model (idle.fbx)...
    </div>

    <!-- Load Three.js core library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load FBXLoader extension (required for .fbx files) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>

    <script type="module">
        // Global variables for the scene
        let scene, camera, renderer, model, messageElement;
        const container = document.getElementById('scene-container');
        messageElement = document.getElementById('message');

        // --- Utility Functions ---

        // Function to handle exponential backoff for retries
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function init() {
            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x2d3748); // Slightly lighter dark background

            // 2. Camera Setup
            const aspect = container.clientWidth / container.clientHeight;
            camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
            camera.position.set(0, 100, 200); // Adjust position to view the model

            // 3. Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true; // Enable shadows for better realism
            container.appendChild(renderer.domElement);

            // 4. Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
            directionalLight.position.set(100, 200, 100);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // 5. Placeholder Object (will be replaced by the FBX model)
            const geometry = new THREE.BoxGeometry(50, 50, 50);
            const material = new THREE.MeshPhongMaterial({ color: 0x4299e1 });
            const placeholder = new THREE.Mesh(geometry, material);
            placeholder.name = 'placeholder';
            placeholder.position.y = 25;
            scene.add(placeholder);

            // 6. Floor/Ground
            const floorGeometry = new THREE.PlaneGeometry(1000, 1000);
            const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x2f4f4f, side: THREE.DoubleSide });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = Math.PI / 2;
            floor.position.y = 0;
            floor.receiveShadow = true; // Floor can receive shadows
            scene.add(floor);

            // 7. Load the FBX Model (with retry logic)
            const maxRetries = 3;
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    messageElement.textContent = `Attempting to load idle.fbx (Attempt ${attempt})...`;
                    // --- CHANGED PATH BACK TO RELATIVE FOR LOCAL HOSTING ---
                    await loadFBXModel('/model/idle.fbx'); 
                    // --------------------------------------------------------
                    messageElement.textContent = 'Model loaded successfully!';
                    messageElement.classList.replace('bg-yellow-500', 'bg-green-500');
                    break; // Exit loop on success
                } catch (error) {
                    console.error(`Error loading model on attempt ${attempt}:`, error);
                    if (attempt < maxRetries) {
                        messageElement.textContent = `Load failed. Retrying in ${Math.pow(2, attempt)}s... Please ensure you are running this page from a web server.`;
                        await delay(Math.pow(2, attempt) * 1000);
                    } else {
                        messageElement.textContent = 'Failed to load idle.fbx after several retries. Check the console for errors and ensure the file path is correct AND you are using a web server.';
                        messageElement.classList.replace('bg-yellow-500', 'bg-red-500');
                    }
                }
            }


            // 8. Event Listeners
            window.addEventListener('resize', onWindowResize, false);

            // 9. Start Animation
            animate();
        }

        /**
         * Loads the FBX model and adds it to the scene.
         * @param {string} url - The path to the FBX file.
         */
        function loadFBXModel(url) {
            return new Promise((resolve, reject) => {
                const loader = new THREE.FBXLoader();

                loader.load(
                    url,
                    (group) => {
                        // Remove the placeholder cube
                        const placeholder = scene.getObjectByName('placeholder');
                        if (placeholder) {
                            scene.remove(placeholder);
                        }

                        // Scale and position the model
                        // You might need to adjust this depending on the size of your model!
                        group.scale.setScalar(1); 
                        group.position.set(0, 0, 0);

                        // Adjust model to be centered and facing correctly if needed
                        group.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });

                        model = group;
                        scene.add(model);
                        resolve();
                    },
                    (xhr) => {
                        // Progress callback (optional)
                        console.log('Loading FBX: ' + (xhr.loaded / xhr.total * 100).toFixed(2) + '%');
                    },
                    (error) => {
                        // Error callback
                        reject(error);
                    }
                );
            });
        }

        // Handle window resizing
        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);

            // Simple camera rotation for visual interest
            camera.position.x = 200 * Math.sin(Date.now() * 0.0002);
            camera.position.z = 200 * Math.cos(Date.now() * 0.0002);
            camera.lookAt(new THREE.Vector3(0, 50, 0)); // Look slightly above the floor

            // Rotate the loaded model if it exists
            if (model) {
                model.rotation.y += 0.005;
            } else {
                // Rotate placeholder cube until model loads
                const placeholder = scene.getObjectByName('placeholder');
                if (placeholder) {
                    placeholder.rotation.x += 0.01;
                    placeholder.rotation.y += 0.01;
                }
            }

            renderer.render(scene, camera);
        }

        // Start the application when the window loads
        window.onload = init;
    </script>
</body>
</html>